EMAILENC TITLE 'ENCODE QSAM FILE FOR EMAIL ATTACHMENTS'
***********************************************************************
*               Encode QSAM file for Email Attachment                 *
*---------------------------------------------------------------------*
* Program: EMAILENC                                                   *
* Purpose: Encode QSAM file for Email Attachment                      *
* Design : Hunter Guanghui Zhou                                       *
*          Phone: 1-(416)-602-9567                                    *
*          E-mail: zhough2000@yahoo.com                               *
* Date   : June 2003                                                  *
* Description:                                                        *
*   This program is designed to encode QSAM file into following file  *
*   formats:                                                          *
*                                                                     *
* Source Type Encode Algorithm EXEC PARM        Description           *
* =========== ================ ================ ======================*
* Text file   Quoted Printable TEXT or QTEPRT   For normal text file  *
* Binary file BASE 64          BINARY or BASE64 For normal binary file*
*                                                                     *
*   The encode mode is determinated by EXEC PARM.                     *
*                                                                     *
* All attachments in email via SMTP protocol must use one of these    *
* two encoding algorithm, depending on the format of the attachment.  *
*                                                                     *
* Installation Instruction                                            *
* ========================                                            *
* 1. Compile                                                          *
*                                                                     *
*    This program is re-entrent 31 bit mode program. You should use   *
* RENT parm in link editor. Here is the sample JCL to compile this    *
* program:                                                            *
*                                                                     *
*   //COMPILE EXEC ASMACL,PARM.L='LIST,RENT'                          *
*   //C.SYSIN   DD DISP=SHR,DSN=SP2487.ASM.SOURCE(EMAILENC)           *
*   //C.SYSLIB  DD DISP=SHR,DSN=SYS1.MACLIB                           *
*   //          DD DISP=SHR,DSN=SYS1.MODGEN                           *
*   //L.SYSLMOD DD DISP=SHR,DSN=SYS1.USER.LINKLIB                     *
*   //L.SYSIN   DD *                                                  *
*     NAME EMAILENC(R)                                                *
*   /*                                                                *
*                                                                     *
*  The target load library can be in your system LINKLST or LPA list. *
*  To refresh the LINKLST, issue following MVS command:               *
*     F LLA,REFRESH                                                   *
*                                                                     *
* User Guide                                                          *
* ==========                                                          *
*                                                                     *
*  The program is usually used with send email programs with SMTP.    *
*  The send mail program can call this program with following         *
*  requirements.                                                      *
*                                                                     *
*  1. Required File Allocation:                                       *
*   INPUT    : The QSAM (Sequential) file to be encoded for email     *
*              attachment. This file can be any format (F,V or U).    *
*              The input DD name can be any pre-allocated DD name.    *
*              If you choose the DD name other than INPUT, you must   *
*              specify the DD name in the second option of EXEC PARM. *
*   OUTPUT   : The encoded file to be saved to. This file must be     *
*              sequential file with fixed block, record length of     *
*              76. The size of this output file should be 33% more    *
*              than the INPUT file. If the input file is 30 tracks,   *
*              the output file should be 40 tracks.                   *
*              The output DD name can be any pre-allocated DD name.   *
*              If you choose the DD name other than OUTPUT, you must  *
*              specify the DD name in the third option of EXEC PARM.  *
*   SYSPRINT : The message file for this program.                     *
*              This DD statement is optional.                         *
*                                                                     *
*  2. Required parameters                                             *
*                                                                     *
*   The parameters is to tell the program to use which algorithm      *
*   to encode the input file. The paramenter is given by EXEC PARM    *
*   The syntax:                                                       *
*                                                                     *
*   PARM='algorithm,inddname,outddname'                               *
*   PARM='algorithm,inddname'                                         *
*   PARM='algorithm'                                                  *
*   PARM=''                                                           *
*                                                                     *
*   algorithm                                                         *
*   =========                                                         *
*                                                                     *
*   First parameter is the encode algorithm as follows:               *
*                                                                     *
*   TEXT or QTEPRT: Use Quoted Printable algorithm to encode the      *
*                   input file. This encoding is for text files.      *
*                   This encoding will truncate all trailing spaces   *
*                   of each record.                                   *
*                                                                     *
*   BINARY or BASE64: Use BASE 64 algorithm to encode the input file. *
*                   This encoding is for binary files, such as ZIP    *
*                   files.                                            *
*                                                                     *
*   inddname                                                          *
*   ========                                                          *
*                                                                     *
*   The second DD name is the DD name for input file, this DD name    *
*   must be pre-allocated before the program is executed.             *
*                                                                     *
*   outddname                                                         *
*   =========                                                         *
*                                                                     *
*   The third  DD name is the DD name for output file, this DD name   *
*   must be pre-allocated before the program is executed.             *
*                                                                     *
*                                                                     *
*   If there is no EXEC PARM, the program will use TEXT as default.   *
*       Algorithm:      TEXT                                          *
*       Input DD name:  INPUT                                         *
*       Output DD Name: OUTPUT                                        *
*                                                                     *
*  Examples                                                           *
*                                                                     *
*   1. Example for encoding text input file:                          *
*                                                                     *
*  //ENCODE  EXEC PGM=EMAILENC,PARM=TEXT                              *
*  //INPUT     DD DISP=SHR,DSN=DC.DSD.TELINK.UPLOAD.MERGED.G1370V00   *
*  //OUTPUT    DD DISP=OLD,DSN=SP2487.TEMP.OUTPUT                     *
*  //SYSPRINT  DD SYSOUT=*                                            *
*                                                                     *
*   2. Example for encoding binary input file:                        *
*                                                                     *
*  //ENCODE  EXEC PGM=EMAILENC,PARM=BINARY                            *
*  //INPUT     DD DISP=SHR,DSN=SP2487.SOFTWARE.ZIP                    *
*  //OUTPUT    DD DISP=OLD,DSN=SP2487.TEMP.OUTPUT                     *
*  //SYSPRINT  DD SYSOUT=*                                            *
*                                                                     *
*   3. Example for using different DD names:                          *
*                                                                     *
*  //ENCODE  EXEC PGM=EMAILENC,PARM='TEXT,IN001,OUT001'               *
*  //IN001     DD DISP=SHR,DSN=DC.DSD.TELINK.UPLOAD.MERGED.G1370V00   *
*  //OUT001    DD DISP=OLD,DSN=SP2487.TEMP.OUTPUT                     *
*  //SYSPRINT  DD SYSOUT=*                                            *
*                                                                     *
*  There is a REXX program SENDMAIL to use this program to send email *
*  via OS/390 SMTP server.                                            *
*  If you need this REXX program, contact with Hunter Zhou.           *
*                                                                     *
*  Here is example to use SENDMAIL program which use this encoding    *
*  program:                                                           *
*                                                                     *
*   //SENDMAIL EXEC PGM=IKJEFT01,PARM=SENDMAIL                        *
*   //SYSEXEC  DD  DSN=SP2487.ZHOUGH.REXX,DISP=SHR                    *
*   //SYSTSPRT DD  SYSOUT=*                                           *
*   //SYSTSIN  DD  DUMMY                                              *
*   //ATTACH   DD  *                                                  *
*   Attachment:                                                       *
*     Dataset      = SP2487.TEMP.SOFTWARE.ZIP                         *
*     Rename       = Software.zip                                     *
*     Format       = BINARY                                           *
*     Description  = Software Installation Package                    *
*   #--end--                                                          *
*   #                                                                 *
*   /*                                                                *
*   //SYSIN   DD  *                                                   *
*   To: "Hunter Zhou"     guanghui.zhou@sobeys.com                    *
*   Subject: The software installation package.                       *
*   Hi Hunter,                                                        *
*                                                                     *
*     This is a sample email from Mainframe.                          *
*                                                                     *
*     For any further support, please contact:                        *
*                                                                     *
*     Hunter Zhou                                                     *
*     Tel: (905) 671-5208                                             *
*     guanghui.zhou@sobeys.com                                        *
*   /*                                                                *
*                                                                     *
***********************************************************************
EMAILENC CSECT
EMAILENC AMODE 31
EMAILENC RMODE ANY
         YREGS
         USING EMAILENC,R15       R15 IS CURRENT ADDRESS, USING IT
         B     START              BRANCH AROUND CONSTANTS
         DC    C' Program Name(EMAILENC)'       MODULE IDENTIFIER
         DC    C' Compile Time(&SYSDATE &SYSTIME)'
         DC    C' Purpose: Encode Sequential file for TCP/IP'
         DC    C' SMTP Email attachment.'
         DC    C' Usage of EXEC PARM: TEXT|QTEPRT for text encoding,'
         DC    C' BINARY|BASE64 for binary encoding.'
         DC    C' Design: Hunter Zhou, zhough2000@yahoo.com     '
START    DS    0H
         SAVE  (14,12)            ;SAVE CALLER'S REGISTERS
         LR    R12,R15            ;COPY THE MY START ADDRESS
         LA    R11,2048(,R12)     ;LOAD R11=R12+4096
         LA    R11,2048(,R11)
         DROP  R15                ;DROP THE TEMPORARY USING
         USING EMAILENC,R12,R11   ;USE R12,R11 AS BASE REGISTERS.
         LR    R7,R1              ;COPY THE CURRENT PARM ADDRESS
         LR    R8,R13             ;COPY THE CALLER'S SAVE AREA ADDR
* DYNAMICALLY ALLOCATE STORAGE FOR DATA AREAS
         GETMAIN RU,LV=DSALEN,LOC=BELOW ;OBTAIN STORAGE FOR DATA AREAS
* AS THE SAVE AREA IS AT START OF DSA DSECT, THE R13 CAN BE BOTH OF
* THE ADDRESSING REGISTER FOR THIS DSECT, AND THE ADDRESS OF OUR SAVE
* AREA, WHICH IS REQUIRED BY LINKAGE FOR LINKAGE CONVENTION.
         LR    R13,R1             ;LOAD STORAGE ADDRESS INTO R13
         USING DSA,R13            ;USING R13 AS DSA ADDRESSING REGS.
         ST    R8,SAVEAREA+4      ;SET OUR BACKWARD LINKAGE
         ST    R13,8(,R8)         ;SET MY SAVE AREA AT CALLER'S AREA
         ST    R7,PARMADR         ;SAVE THE EXEC PARM ADDRESS
* INITIALIZE BUFFERS
         BAL   R2,INITIAL         ;INITIALIZE BUFFERS
         CLI   RETCODE,ZERO       ;TEST RETURN CODE
         BNE   RETURN
* READ THE EXEC PARM
         BAL   R2,READPARM        ;INITIALIZE BUFFERS
         CLI   RETCODE,ZERO       ;TEST RETURN CODE
         BNE   MAIN2000
* OPEN FILES
         BAL   R2,OPENFILE        ;OPEN FILES
         CLI   RETCODE,ZERO       ;TEST RETURN CODE
         BNE   MAIN2000
* PROCESS FILE
         BAL   R2,PROCFILE
         CLI   RETCODE,ZERO       ;TEST RETURN CODE
         BNE   MAIN2000
* CLOSE FILE
MAIN2000 EQU   *
         BAL   R2,SHOWINFO        ;RETURN CODE IS IN R9
         BAL   R2,CLOSFILE        ;CLOSE ALL FILES
*  RETURN LINKAGE
RETURN   EQU   *
         XR    R9,R9              ;CLEAR R9
         IC    R9,RETCODE         ;LOAD RETURN CODE TO R9
         L     R8,SAVEAREA+4      ;LOAD THE CALLER'S SAVE AREA
         FREEMAIN RU,LV=DSALEN,A=(R13)  ; FREE ALLOCATED STOR
         LR    R13,R8             ;RESTORE CALL'S SAVE AREA
         LR    R15,R9             ;SET RETURN CODE TO R15
         RETURN (14,12),RC=(15)   ;RESTORE CALLER'S REGS AND RETURN
*---------------------------------------------------------------------*
* ROUTINE: INITIAL
* DESCRIPTION: INITIALIZE ALL BUFFERS
* INPUT:
*    R2  : RETURN CONTROL
* RETURN :
*---------------------------------------------------------------------*
INITIAL  EQU    *
         MVI   RETCODE,ZERO       ;RESET RETURN CODE
* SET THE DEFAULT VALUES
         MVI   DATAFMT,QTEPRT              DEFAULT DATA IS QTEPRT
         MVC   INDDNAME,DEFTINDD           DEFAULT INPUT DDNAME
         MVC   OUDDNAME,DEFTOUDD           DEFAULT OUTPUT DDNAME
* INITIALIZE INPUT DCB
         MVC   INPDCB(CINPDCBL),CINPDCB    COPY DCB
         MVC   INPDCBE(DCBE$LEN),CINPDCBE  COPY DCBE
         MVC   INPOPNLF(CINPOPLL),CINPOPL  COPY OPEN LIST FORM
         MVC   INPCLSLF(CINPCLSL),CINPCLS  COPY CLOSE LIST
         LA    R4,INPDCBE
         ST    R4,INPDCB+(DCBDCBE-IHADCB)  UPDATE DCBE IN DCB
         LA    R4,INPDCB
         ST    R4,INPOPNLF+4               UPDATE DCB IN OPEN LIST
         ST    R4,INPCLSLF+4               UPDATE DCB IN CLOSE LIST
         MVI   INPOPNFL,NO                 SET OPEN FLAG TO NO
* INITIALIZE OUTPUT DCB
         MVC   OUTDCB(COUTDCBL),COUTDCB    COPY DCB
         MVC   OUTDCBE(DCBE$LEN),COUTDCBE  COPY DCBE
         MVC   OUTOPNLF(COUTOPLL),COUTOPL  COPY OPEN LIST
         MVC   OUTCLSLF(COUTCLSL),COUTCLS  COPY CLOSE LIST
         LA    R4,OUTDCBE
         ST    R4,OUTDCB+(DCBDCBE-IHADCB)  UPDATE DCBE IN DCB
         LA    R4,OUTDCB
         ST    R4,OUTOPNLF+4               UPDATE DCB IN OPEN LIST
         ST    R4,OUTCLSLF+4               UPDATE DCB IN CLOSE LIST
         MVI   OUTOPNFL,NO                 SET OPEN FLAG TO NO
* INITIALIZE SYSPRINT DCB
         MVC   SPRDCB(CSPRDCBL),CSPRDCB    COPY DCB
         MVC   SPRDCBE(DCBE$LEN),CSPRDCBE  COPY DCBE
         MVC   SPROPNLF(CSPROPLL),CSPROPL  COPY OPEN LIST
         MVC   SPRCLSLF(CSPRCLSL),CSPRCLS  COPY CLOSE LIST
         LA    R4,SPRDCBE
         ST    R4,SPRDCB+(DCBDCBE-IHADCB)  UPDATE DCBE IN DCB
         LA    R4,SPRDCB
         ST    R4,SPROPNLF+4               UPDATE DCB IN OPEN LIST
         ST    R4,SPRCLSLF+4               UPDATE DCB IN CLOSE LIST
         MVI   SPROPNFL,NO                 SET OPEN FLAG TO NO
* INITIALIZE OTHER STUFF
         XC    INBUFADR(4),INBUFADR        CLEAR INPUT RECORD BUF ADR
         MVI   REMCTR,ZERO                 RESET THE REMAIN COUNTER
         LA    R6,OUTREC                   LOAD ADDRESS OF OUTPUT REC
         ST    R6,OUTPOS                   SAVE TO CURRENT POSITION
         ZAP   MSGCTR,P0                   RESET THE MSG LINE COUNTER
* OPEN SYSPRINT DCB
         OPEN  (SPRDCB,(OUTPUT)),MODE=31,MF=(E,SPROPNLF)
         LTR   R15,R15              OPEN SUCCESS?
         BNZ   INI8000              NO, SKIP THE SYSPRINT
         MVI   SPROPNFL,YES         SET OPEN FLAG TO YES
INI8000  EQU   *
* RETURN
         BR    R2
* END OF SUB-ROUTINE INITIAL
*---------------------------------------------------------------------*
* ROUTINE: READPARM
* DESCRIPTION: READ AND VALIDATE THE EXEC PARM
*
* STEPS:
*   PARSE THE PARM TEXT
*  READ EACH WORD IN PARM
*     IF THIS IS THE FIRST PARM, CALL FORMAT ROUTINE
*     IF THIS IS THE SECOND PARM, CALL INPUT DD ROUTINE
*     IF THIS IS THE THIRD PARM, CALL OUTPUT DD ROUTINE
*
*  FORMAT ROUTINE:
*     IF THE WORD MATCH 'TEXT' OR 'QTEPRT' USE TEXT
*     IF THE WORD MATCH 'BINARY' OR 'BASE64' USE BINARY
*     OTHERWISE SHOW THE ERROR MESSAGE
*
*  INPUT DD ROUTINE:
*     IF THE LENGTH IS LESS THAN 8, COPY THE DD NAME
*     OTHERWISE SHOW THE ERROR MESSAGE
*
*  OUTPUT DD ROUTINE:
*     IF THE LENGTH IS LESS THAN 8, COPY THE DD NAME
*     OTHERWISE SHOW THE ERROR MESSAGE
*
* INPUT:
*    R2  : RETURN CONTROL
*    R7  : EXEC PARM ADDRESS
* RETURN :
*   DATAFMT: EITHER TEXT OR BINARY
*   RETCODE: 0 IF VALID PARM, 8 IF INVALID PARM
*---------------------------------------------------------------------*
READPARM EQU    *
         STM   R0,R15,SVLVL1      ;SAVE THE REGISTERS
         MVI   RETCODE,ZERO       ;RESET RETURN CODE
* PRINT WELCOME MESSAGE
         MVI   MSGID,MSG001I
         BAL   R4,WRITELOG
         MVI   MSGID,MSG002I
         BAL   R4,WRITELOG
         MVI   MSGID,MSG003I
         BAL   R4,WRITELOG
* READ PARM
         XR    R1,R1
         STH   R1,PRMWSEQ         ;RESET THE SEQUENCE ID
         L     R7,PARMADR         ;READ PARM ADDRESS
         L     R7,0(R7)           ;PARM ADDRESS
         LH    R5,0(R7)           ;LENGTH OF PARM
         LTR   R5,R5              ;TEST IF PARM IS ZERO
         BZ    RDP7000            ;IF NO PARM, USE DEFAULT
* START TO PARSE THE PARMTEXT
* R10: COUNTER, THE LENGTH OF PARM
* R8: THE START OF WORD
* R9: THE CURRENT OF THE WORD (LAST POSITION OF THE WORD)
         LR    R10,R5             ;
         LA    R8,2(,R7)          ;R8: START OF THE DATA
         LR    R9,R8              ;R9: CURRENT POINT POSITION
RDP1000  EQU   *
         CLI   0(R9),C' '         ;TEST IF THIS IS A SEPARATOR
         BE    RDP2000            ;IF YES, GET A WORD, TEST IT
         CLI   0(R9),C','         ;TEST IF THIS IS A SEPARATOR
         BE    RDP2000            ;IF YES, GET A WORD, TEST IT
         LA    R9,1(0,R9)         ;MOVE TO THE NEXT BYTE
RDP1500  BCT   R10,RDP1000        ;CONTINUE TO TILL THE END
* GET A WORD.
RDP2000  EQU   *
         CR    R8,R9              COMPARE THE START AND END POINTER
         BE    RDP4000            SKIP TO PROCESS THIS EMPTY WORD
* TEST THIS WORD
         MVI   PRMWORD,C' '
         MVC   PRMWORD+1(L'PRMWORD),PRMWORD
*
         LA    R6,PRMWORD
         LR    R7,R8
         LR    R5,R9
         SR    R5,R8
         BCTR  R5,0
* TEST THE LENGTH OF THE WORD
         LA    R1,7               SET THE MAXIMUM LENGTH TO 7 (0-7)
         CR    R5,R1              COMPARE THE CURRENT WORD LENGTH
         BH    RDP0800            MESSAGE IS TOO LONG
         EX    R5,MVCREC          COPY THE WORD
         STH   R5,PRMWLEN         SAVE THE WORD LENGTH
         LH    R1,PRMWSEQ         ADD THE SEQUENCE
         LA    R1,1(0,R1)
         STH   R1,PRMWSEQ         ;SET THE SEQ TO FIRST.
* IF THE SEQUENCE IS 1, CALL THE FORMAT PARMETER
         CLI   PRMWSEQ+1,X'01'
         BNE   RDP3000
         BAL   R3,RDPFMT00        CALL READ FORMAT PARAMETER
         B     RDP4000
* IF THE SEQUENCE IS 2, CALL THE INPUT DD PARMETER
RDP3000  EQU   *
         CLI   PRMWSEQ+1,X'02'
         BNE   RDP3500
         LA    R7,PRMWORD         LOAD THE START OF THE WORD
         LA    R6,INDDNAME        LOAD THE INPUT DD STORAGE ADDRESS
         LH    R5,PRMWLEN         LOAD THE LENGTH OF THE WORD
         EX    R5,MVCREC
         B     RDP4000
* IF THE SEQUENCE IS 3, CALL THE OUTPUT DD PARMETER
RDP3500  EQU   *
         CLI   PRMWSEQ+1,X'03'
         BNE   RDP4000            MORE THAN 3 PARAMETERS
         LA    R7,PRMWORD         LOAD THE START OF THE WORD
         LA    R6,OUDDNAME        LOAD THE INPUT DD STORAGE ADDRESS
         LH    R5,PRMWLEN         LOAD THE LENGTH OF THE WORD
         EX    R5,MVCREC
         B     RDP4000
* PREPARE FOR NEXT MOVE
RDP4000  EQU   *
         LA    R9,1(0,R9)         MOVE WORD START POINTER TO NEXT
         LR    R8,R9
         LTR   R10,R10
         BNZ   RDP1500            ;IF THE LENGTH IS NOT 0, CONTINUE
         B     RDP7000
* END OF THE LOOP
RDP7000  EQU   *
         LA    R10,INPDCB
         USING IHADCB,R10
         MVC   DCBDDNAM(8),INDDNAME  COPY THE DDNAME
         DROP  R10
         LA    R10,OUTDCB
         USING IHADCB,R10
         MVC   DCBDDNAM(8),OUDDNAME  COPY THE DDNAME
         DROP  R10
* Show the input DD infomration
         MVC   MSGBUFTX(34),=CL34'EME024I The input data is from DD '
         MVC   MSGBUFTX+34(8),INDDNAME
         MVI   MSGBUFTX+42,C'.'
         MVI   MSGBUFLN,43
         MVI   MSGID,MSGCUST
         BAL   R4,WRITELOG
* Show the input DD infomration
         MVC   MSGBUFTX(33),=CL33'EME025I The output data is to DD '
         MVC   MSGBUFTX+33(8),OUDDNAME
         MVI   MSGBUFTX+41,C'.'
         MVI   MSGBUFLN,42
         MVI   MSGID,MSGCUST
         BAL   R4,WRITELOG
         B     RDP9000
RDP0800  EQU   *
         MVI   RETCODE,X'08'      ;SET THE RETURN CODE AS 8
         MVI   MSGID,MSG015I
         BAL   R4,WRITELOG
         B     RDP9000
RDP0810  EQU   *
         MVI   RETCODE,X'08'      ;SET THE RETURN CODE AS 8
         MVI   MSGID,MSG016I
         BAL   R4,WRITELOG
         B     RDP9000
RDP9000  EQU   *
         LM    R0,R15,SVLVL1      RESTORE THE SAVED REGISTERS
         BR    R2

************************************************
* READ FORMAT WORD OF THE PARAMETER
RDPFMT00 EQU   *
         STM   R0,R15,SVLVL2      ;SAVE THE REGISTERS
         LA    R7,PRMWORD         LOAD THE START OF THE WORD
         LH    R5,PRMWLEN         LOAD THE LENGTH OF THE WORD
* TEST IF THE PARM IS 4 BYTES
         CLI   PRMWLEN+1,X'03'
         BNE   RDPF1000
         CLC   0(4,R7),PARMTXT
         BE    RDPF3000
         B     RDPF8000
* TEST IF THE PARM IS 6 BYTES
RDPF1000 EQU   *
         CLI   PRMWLEN+1,X'05'
         BNE   RDPF8000
         CLC   0(6,R7),PARMQTE
         BE    RDPF3000
         CLC   0(6,R7),PARMBIN
         BE    RDPF4000
         CLC   0(6,R7),PARMBSE
         BE    RDPF4000
         B     RDPF8000
* SET encoding algorithm: Test: Quoted Printable
RDPF3000 MVI   DATAFMT,QTEPRT     ;DEFAULT DATA IS QTEPRT
         MVI   MSGID,MSG004I
         B     RDPF9000
* SET encoding algorithm: Binary: BASE 64
RDPF4000 MVI   DATAFMT,BASE64
         MVI   MSGID,MSG005I
         B     RDPF9000
RDPF8000 MVI   RETCODE,X'08'      ;SET THE RETURN CODE AS 8
         MVI   MSGID,MSG010I
RDPF9000 BAL   R4,WRITELOG
         LM    R0,R15,SVLVL2      RESTORE THE SAVED REGISTERS
         BR    R3
*---------------------------------------------------------------------*
* ROUTINE: PROCFILE
* DESCRIPTION: PROCESS THE INPUT FILE
* INPUT:
*    R2  : RETURN CONTROL
* RETURN :
*  INPRECST : THE START OF THE RECORD
*  INPLRECL : THE LENGTH OF RECORD, THE TRAILING SPACES NOT INCLUDED
*---------------------------------------------------------------------*
PROCFILE EQU   *
         ST    R2,SVLVL1           SAVE R2
         XR    R2,R2               CLEAR THE RECORD COUNTER
PRF1000  EQU   *
         BAL   R3,READREC          READ NEXT RECORD
         CLI   INPEOF,YES          REACH AT THE END OF INPUT FILE?
         BE    PRF2000             YES, FINISH TO PROCESS
         LA    R2,1(,R2)           ADD THE COUNTER
         CLI   DATAFMT,QTEPRT      TEST THE DATA FORMAT IS TEXT?
         BE    PRF1500             YES, PROCESS THE TEXT RECORD
         BAL   R3,PRBASE64         PROCESS THE BINARY RECORD
         B     PRF1000
PRF1500  BAL   R3,PRQTEPRT         PROCESS THE TEXT RECORD
         B     PRF1000
PRF2000  EQU   *
* PROCESS THE LAST OUTPUT RECORD
         CLI   DATAFMT,BASE64      TEST THE DATA FORMAT IS BINARY?
         BNE   PRF9000             NO, SKIP THE REST RECORD
         XR    R3,R3               SET R3 AS 0
         ST    R3,INPLRECL         SET THE RECORD LENGTH AS 0.
         BAL   R3,PRBASE64         PROCESS THE LAST OUTPUT RECORD
PRF9000  EQU   *
         ST    R2,TOLIRCBI         SAVE THE TOTAL RECORD
         L     R2,SVLVL1           RESTORE R2
         BR    R2
*---------------------------------------------------------------------*
* ROUTINE: PRBASE64
* DESCRIPTION: PROCESS ONE RECORD OF THE INPUT FILE AS BASE64
* INPUT:
*       R3  : RETURN CONTROL
*  INPRECST : THE START OF THE RECORD
*  INPLRECL : THE LENGTH OF RECORD
* RETURN    :  none
* HOW IT WORKS:
* ============
*  BASE64 Concept:
*
*  The BASE 64 is to convert the three 8 bit group data (24 bits) into
*  four 6 bit group displayable data, which is converted on the table
*  of base 64 alphabet characters as follows:
*      0 - 25: A-Z
*     26 - 51: a-z
*     52 - 61: 0-9
*     62 - 63: +/
*  At the end of the file, the input bytes should pad with binary 0
*  to build the last 3 byte group, and the converted 4 bytes should
*  be padded with the same number of '='. i.e. If there are 2 binary
*  zeros padded into 3 byte group (just one byte left in last record),
*  the third and fourth byte of converted 4 byte group are filled
*  with '='.
*
*  The output record must be 76 bytes long. The last record will
*  padding with spaces if it less than 76 bytes.
*
*  Program Logic:
*
*  1. Read next 3 byte from input record into R5.
*  2. Convert 3 byte group into BASE64 by call sub-rountine CONVERTB,
*     the 4 byte output is also in R5.
*  3. Save the converted 4 bytes in R5 into output record.
*  4. If the output record is full, save the output record.
*  5. Repeat from step 1 till the end of the record.
*  6. If there is any byte left (0, 1 or 2), save the bytes in REMBYTES
*     and the number of bytes in REMCTR.
*  7. Before process next record, process these 1 or 2 left byte in
*     in previous record. Read 1 or 2 bytes from next record to
*     build up first one 3 byte group. Then continue at step 1.
*  8. When the record length is 0, process the last output record.
*
*---------------------------------------------------------------------*
PRBASE64 EQU   *
         L     R6,OUTPOS           LOAD CURRENT ADDRESS OF OUTPUT REC
         L     R7,INPRECST         LOAD THE RECORD START ADDRESS
         L     R8,INPLRECL         LOAD THE RECORD LENGTH
         LA    R9,OUTREC           LOAD THE START ADDRESS OF OUTPUT
         LA    R9,76(,R9)          LOAD THE END OF OUTPUT RECORD
         LA    R10,3               LOAD THE GROUP BYTE LENGTH
* TEST IF REQUEST THE LAST OUTPUT RECORD (INPUT LRECL==0)
         LTR   R8,R8
         BZ    PRB5000             IF RECLEN==0, THEN PROCESS LAST REC
* TEST IF ANY BYTE LEFT OF PREVIOUS RECORD
         CLI   REMCTR,ZERO         IS THERE NO BYTE LEFT?
         BE    PRB1000             YES, SKIP THE PROCESS THE REST BYTES
* PROCESS THE REST BYTES IN PREVIOUS RECORD
         XR    R5,R5
         CLI   REMCTR,TWO          THE REST BYTES ARE 2?
         BE    PRB0200             YES, PROCESS THE TWO BYTES
* PROCESS ONLY ONE BYTE
         IC    R5,REMBYTES         READ ONLY ONE BYTE
         SLL   R5,16               SHIFT R5 BY 16 BITS
         ICM   R5,B'0011',0(R7)    READ 2 NEW BYTES FROM CURRENT INPUT
         LA    R7,2(,R7)           MOVE CURRENT INPUT LOCATION
         BCTR  R8,0                DECREASE THE RECORD LENGTH BY 2
         BCTR  R8,0
         B     PRB0500
* PROCESS TWO BYTES
PRB0200  EQU   *
         ICM   R5,B'0011',REMBYTES READ TWO BYTES
         SLL   R5,8                SHIFT R5 BY 16 BITS
         IC    R5,0(R7)            READ 1 NEW BYTE FROM CURRENT INPUT
         LA    R7,1(,R7)           MOVE CURRENT INPUT LOCATION
         BCTR  R8,0                DECREASE THE RECORD LENGTH BY 1
* PROCESS THE REMAIN 3 BYTE GROUP
PRB0500  EQU   *
         BAL   R4,CONVERTB         CONVERT BYTE GROUP INTO BASE64 IN R5
         STCM  R5,B'1111',0(R6)    SAVE CONVERTED BYTES INTO OUTPUT
         LA    R6,4(,R6)           MOVE R6 TO NEW OUTPUT LOCATION
* PROCESS THE INCOMING RECORD
PRB1000  EQU   *
         CR    R6,R9               TEST IF OUTPUT RECORD IS FULL
         BL    PRB1500             NO, CONTINUE TO PROCESS
         BAL   R4,SAVEREC          SAVE OUTPUT RECORD AND RESET R6
PRB1500  EQU   *
         CR    R8,R10              TEST IF LESS 3 BYTES LEFT
         BL    PRB4000             YES, JUMP OUT OF LOOP
* PROCESS THIS 3 BYTE GROUP
         ICM   R5,B'0111',0(R7)    READ NEXT 3 BYTES
         BAL   R4,CONVERTB         CONVERT BYTE GROUP INTO BASE64 IN R5
         STCM  R5,B'1111',0(R6)    SAVE CONVERTED BYTES INTO OUTPUT
         LA    R6,4(,R6)
         AR    R7,R10              MOVE TO NEXT 3 GROUP BYTES
         SR    R8,R10              DECREASE THE INPUT LENGTH BY 3
         B     PRB1000             PROCESS NEXT GROUP
* PROCESS LAST BYTES IN CURRENT RECORD
PRB4000  EQU   *
         ST    R6,OUTPOS           SAVE THE CURRENT OUTPUT POSITION
         STC   R8,REMCTR           SAVE THE REST BYTE LENGTH
         LTR   R8,R8               TEST IF ANY LEFT
         BZ    PRB9000             IF NOT, JUST RETURN
         MVC   REMBYTES(2),0(R7)   COPY THE MAXIMUM TWO BYTES
         B     PRB9000             END OF THE RECORD PROCESSING
* PROCESS THE LAST OUTPUT RECORD
PRB5000  EQU   *
         CLI   REMCTR,ZERO         IS NO BYTE LEFT?
         BE    PRB5500             YES, SKIP THE PROCESS THE REST BYTE
         XR    R5,R5               CLEAR R5
         CLI   REMCTR,TWO          THE REST BYTES ARE 2?
         BE    PRB5200             YES, PROCESS TWO BYTES
* PROCESS ONLY ONE BYTE
         IC    R5,REMBYTES         LOAD THE LAST BYTE
         SLL   R5,16               SHIFT LEFT BY 2 BYTES
         BAL   R4,CONVERTB         CONVERT BYTE GROUP INTO BASE64 IN R5
         STCM  R5,B'1111',0(R6)    SAVE CONVERTED BYTES INTO OUTPUT
         MVI   2(R6),C'='          PAD THE THIRD BYTE W/ =
         MVI   3(R6),C'='          PAD THE LAST(FOURTH) BYTE W/ =
         LA    R6,4(,R6)           MOVE R6 TO NEW OUTPUT LOCATION
         B     PRB5500
* PROCESS TWO BYTES
PRB5200  EQU   *
         ICM   R5,B'0011',REMBYTES
         SLL   R5,8                SHIFT LEFT BY 1 BYTE
         BAL   R4,CONVERTB         CONVERT BYTE GROUP INTO BASE64 IN R5
         STCM  R5,B'1111',0(R6)    SAVE CONVERTED BYTES INTO OUTPUT
         MVI   3(R6),C'='          PAD THE LAST(FOURTH) BYTE W/ =
         LA    R6,4(,R6)           MOVE R6 TO NEW OUTPUT LOCATION
* SAVE THE LAST OUTPUT RECORD
PRB5500  EQU   *
         BAL   R4,SAVEREC          SAVE LAST RECORD
PRB9000  EQU   *
         BR    R3
*---------------------------------------------------------------------*
* ROUTINE: PRQTEPRT
* DESCRIPTION: PROCESS ONE RECORD OF THE INPUT FILE AS TEXT FORMAT
* INPUT:
*       R3  : RETURN CONTROL
*  INPRECST : THE START OF THE RECORD
*  INPLRECL : THE LENGTH OF RECORD, THE TRAILING SPACES NOT INCLUDED
* RETURN    :
*           :
* WORK      :
*   THE PROCESS USE THE EBCDIC TABLE TO LOCATE THE CHARSET, TO GET
*   BETTER PERFORMANCE. SAVE UP TO 3 TIMES OF PROCESSING TIME COMPARING
*   TO USING SRST TO SEARCH AGAINST THE CHARSET TABLE.
*
*       R4  : WORK
*       R5  : THE CONTENT OF CURRENT BYTE
*       R6  : CURRENT POSITION OF OUTREC
*       R7  : CURRENT POSITION OF INPUT RECORD
*       R8  : RECORD LENGTH
*       R9  : THE LAST POSITION FOR NORMAL CHAR
*       R10 : THE LAST POSITION FOR =HEX  CHAR
*
* HOW IT WORKS
* ============
*
*  Quoted Printable Concept
*
*  Quoted Printable encoding is for text data. It will test each byte
*  of input data to test if it is in printable table. If not, it will
*  be translated into 3 byte group: = and two displayble HEX of the
*  byte. The displayable HEX is ASCII HEX, not EBCDIC. If it's in the
*  displayable table, it will not be changed. The table are 65 bytes:
*  A-Z,a-z,0-9,+/ and space.
*
*  The output record must be 76 bytes long. If the record is more
*  than 76 bytes, the record will be wrapped around, and the last
*  byte (76th) will be '=' to indicate the record continuation.
*
*  If the record, or continuation of record is less than 76 bytes,
*  it will be padded with spaces.
*
*  Program Logic
*
*  1. Read next byte of the input record.
*  2. Test the byte is in displayable table.
*  3. If yes, just copy the byte from input record to output record
*     If not, convert the byte (in R5) to displayable ASCII HEX text.
*     leading with '=', i.e. The charater '*' will translated into
*     =2A in output record.
*  4. If the output record is full, save the output record.
*  5. Repeat the step 1 till the end of the input record.
*
*---------------------------------------------------------------------*
PRQTEPRT EQU *
         XR    R5,R5               CLEAR CURRENT BYTE
         LA    R6,OUTREC           LOAD THE ADDRESS OF OUTPUT REC
         L     R7,INPRECST         LOAD THE RECORD START ADDRESS
         L     R8,INPLRECL         LOAD THE RECORD LENGTH
         LA    R9,74(,R6)          SET LAST POSITION FOR CHAR
         LA    R10,72(,R6)         SET LAST POSITION FOR HEX
PRQ1000  EQU   *
         IC    R5,0(R7)            READ NEXT BYTE
* SEARCH THE CHARSET TABLE TO SEE IF THE BYTE IS IN TABLE
* PROCESS +/ AND SPACE
         LA    R4,C' '
         CR    R5,R4
         BE    PRQ2000
         LA    R4,C'+'
         CR    R5,R4
         BE    PRQ2000
         LA    R4,C'/'
         CR    R5,R4
         BE    PRQ2000
* process a-i
         LA    R4,C'a'
         CR    R5,R4
         BL    PRQ3000             IF < a THEN CONVERT IT
         LA    R4,C'i'             BETWEEN a AND i, COPY IT
         CR    R5,R4
         BNH   PRQ2000
* process j-r
         LA    R4,C'j'
         CR    R5,R4
         BL    PRQ3000             IF < a THEN CONVERT IT
         LA    R4,C'r'             BETWEEN j AND r, COPY IT
         CR    R5,R4
         BNH   PRQ2000
* process s-z
         LA    R4,C's'
         CR    R5,R4
         BL    PRQ3000             IF < a THEN CONVERT IT
         LA    R4,C'z'             BETWEEN s AND z, COPY IT
         CR    R5,R4
         BNH   PRQ2000
* process A-I
         LA    R4,C'A'
         CR    R5,R4
         BL    PRQ3000             IF < a THEN CONVERT IT
         LA    R4,C'I'             BETWEEN A AND I, COPY IT
         CR    R5,R4
         BNH   PRQ2000
* process J-R
         LA    R4,C'J'
         CR    R5,R4
         BL    PRQ3000             IF < J THEN CONVERT IT
         LA    R4,C'R'             BETWEEN J AND R, COPY IT
         CR    R5,R4
         BNH   PRQ2000
* process S-Z
         LA    R4,C'S'
         CR    R5,R4
         BL    PRQ3000             IF < S THEN CONVERT IT
         LA    R4,C'Z'             BETWEEN S AND Z, COPY IT
         CR    R5,R4
         BNH   PRQ2000
* process 0-9
         LA    R4,C'0'
         CR    R5,R4
         BL    PRQ3000             IF < 0 THEN CONVERT IT
         LA    R4,C'9'             BETWEEN 0 AND 9, COPY IT
         CR    R5,R4
         BH    PRQ3000             For >9, CONVERT IT
* CHAR IS FOUND IN CHARSET
PRQ2000  EQU   *
         CR    R6,R9               IS AT THE LAST OF OUTPUT RECORD?
         BL    PRQ2500             NO, CONTINUE TO PROCESS
         MVI   0(R6),C'='          SET RECORD CONTINUATION CHAR =
         LA    R6,1(,R6)           MOVE TO NEXT BYTE OF OUTPUT REC
         BAL   R4,SAVEREC          SAVE THE CURRENT OUTPUT RECORD
PRQ2500  EQU   *
         STC   R5,0(R6)            SAVE THE CURRENT BYTE
         LA    R6,1(,R6)           MOVE THE CURRENT OUTPUT POSITION
         B     PRQ4000             CONTINUE NEXT BYTE
* CHAR IS NOT FOUND IN CHARSET
PRQ3000  EQU   *
         CR    R6,R10              IS AT THE LAST OF OUTPUT RECORD?
         BL    PRQ3200             NO, CONTINUE TO PROCESS
         MVI   0(R6),C'='          SET RECORD CONTINUATION CHAR =
         LA    R6,1(,R6)           MOVE TO NEXT BYTE OF OUTPUT REC
         BAL   R4,SAVEREC          SAVE THE CURRENT OUTPUT RECORD
* CONVERT THE CURRENT BYTE TO DISPLAYABLE HEX TEXT.
PRQ3200  EQU   *
         MVI   0(R6),C'='          SAVE HEX = LEADING CHAR
         BAL   R4,CONVERTX         CALL CONVERT HEX TO TEXT IN R5
         STCM  R5,B'0011',1(R6)    SAVE THE TWO BYTES TO OUTREC
         XR    R5,R5               CLEAR R5
         LA    R6,3(,R6)           MOVE THE CURRENT OUTPUT POSITION
* CONTINUE TO PROCESS NEXT BYTE
PRQ4000  EQU   *
         LA    R7,1(,R7)           MOVE TO NEXT BYTE
         BCT   R8,PRQ1000          PROCESS NEXT BYTE
         BAL   R4,SAVEREC          SAVE THE LAST OUTPUT RECORD
         BR    R3
*---------------------------------------------------------------------*
* ROUTINE: SAVEREC
* DESCRIPTION: SAVE ONE RECORD OF THE OUTPUT FILE
* INPUT:
*       R4  : RETURN CONTROL
*       R6  : THE LAST POSITION OF OUTPUT RECORD
*   OUTREC  : THE OUTPUT RECORD
* RETURN :
*       R6  : THE START ADDRESS OF OUTPUT RECORD
* WORK:
*       R14 : THE COPY OF R5
*       R15 : THE COPY OF R7
*---------------------------------------------------------------------*
SAVEREC  EQU   *
* FILL THE TRAILING BYTES WITH SPACES
         STM   R5,R7,SVLVL2        SAVE R5 TO R7
         LA    R5,OUTREC           LOAD THE OUTPUT ADDRESS
         CR    R6,R5               IS THE CURRRENT POSITION AT START
         BE    SVR9000             YES, SKIP TO SAVE THE RECORD
         LA    R5,76(,R5)          MOVE TO THE END OF THE RECORD
         CR    R6,R5               IS THE CURRRENT POSITION AT THE END?
         BE    SVR4000             YES, JUST PROCESS SAVE RECORD
         MVI   0(R6),C' '          SAVE CURRENT BYTE AS SPACE
         BCTR  R5,0
         CR    R6,R5               IS THE RECORD THE LAST BUT ONE?
         BH    SVR4000             YES, JUST SAVE THE RECORD
         LA    R7,0(,R6)           LOAD COPY FROM IN R7
         LA    R6,1(,R6)           LOAD COPY TO   IN R6
         LA    R5,2(,R5)           INCREASE R5 BY 2
         SR    R5,R6               LOAD THE COPY LENGTH IN R5
         EX    R5,MVCREC           COPY THE SPACES
* SAVE THE CURRENT OUTPUT RECORD
SVR4000  EQU   *
         PUT   OUTDCB,OUTREC       SAVE THE CURRENT OUTPUT RECORD
         L     R5,TOLORCBI
         LA    R5,1(,R5)
         ST    R5,TOLORCBI
SVR9000  EQU   *
         LM    R5,R7,SVLVL2        SAVE R5 TO R7
         LA    R6,OUTREC           UPDATE R6 WITH START ADDRESS OF OUT
         BR    R4
*---------------------------------------------------------------------*
* ROUTINE: READREC
* DESCRIPTION: READ ONE RECORD FROM INPUT FILE
* INPUT:
*    R3  : RETURN CONTROL
* RETURN :
*  INPRECST : THE START OF THE RECORD
*  INPLRECL : THE LENGTH OF RECORD, THE TRAILING SPACES NOT INCLUDED
*---------------------------------------------------------------------*
READREC  EQU    *
         LA    R4,INPDCB
         USING IHADCB,R4
         L     R7,INBUFADR         LOAD THE INPUT RECORD BUFFER
         GET   INPDCB,((R7))       GET NEXT RECORD INTO BUFFER
* PROCESSING RECORD FORMATS
         XR    R5,R5               CLEAR R5
         CLI   INPRECFM,C'V'       THE RECORD FORMAT IS VARIABLE?
         BE    RDR1200             PROCESS VARIABLE LENGTH
* PROCESSING FIXED LENGTH AND UNDEFINED LENGTH
         ICM   R5,B'0011',DCBLRECL LOAD THE RECORD LENGTH FROM DCBLRECL
         B     RDR2000
* PROCESSING VARIABLE LENGTH
RDR1200  EQU   *
         ICM   R5,B'0011',0(R7)    LOAD THE RECORD LENGTH FROM RDW
         LA    R6,4                SET THE RDW LENGTH
         SR    R5,R6               SUBTRACT R5 BY 4 TO SKIP THE RDW
         AR    R7,R6               SKIP THE RDW
RDR2000  EQU   *
         ST    R7,INPRECST         UPDATE THE RECORD START ADDRESS
         CLI   DATAFMT,QTEPRT      IS THE DATA TEXT FORMAT
         BNE   RDR2200             NO, SKIP TO TRUNCATE THE SPACES
* TRUNCATE THE TRAILING SPACES
         AR    R7,R5               MOVE R7 TO THE END OF THE RECORD
         BCTR  R7,0
RDR2100  EQU   *
         BCTR  R7,0
         CLI   0(R7),C' '          COMPARE BYTE WITH SPACE
         BNE   RDR2200             NON-SPACE, OUT OF LOOP
         BCT   R5,RDR2100          TEST NEXT BYTE TILL THE LENGTH IS 0
         LA    R5,1                AT LEAST ONE SPACE FOR SPACE LINE
RDR2200  EQU   *
         ST    R5,INPLRECL         SAVE THE RECORD LENGTH
         B     RDR9000
EODADRTN EQU   *                   INDICATE END-OF-FILE
         MVI   INPEOF,YES
RDR9000  EQU   *
         DROP  R4
         BR    R3
*---------------------------------------------------------------------*
* ROUTINE: OPENFILE
* DESCRIPTION: OPEN THE FILES
* INPUT:
*    R2  : RETURN CONTROL
* RETURN :
*---------------------------------------------------------------------*
OPENFILE EQU   *
* OPEN INPUT DCB
         OPEN  (INPDCB,(INPUT)),MODE=31,MF=(E,INPOPNLF)
         LTR   R15,R15              OPEN SUCCESS?
         BNZ   OPN8000              NO, JUMP TO ERROR PROCESSING
         MVI   INPOPNFL,YES         SET OPEN FLAG TO YES
         MVI   INPEOF,NO            SET EOF FLAG TO NO
* OPEN OUTPUT DCB
         OPEN  (OUTDCB,(OUTPUT)),MODE=31,MF=(E,OUTOPNLF)
         LTR   R15,R15              OPEN SUCCESS?
         BNZ   OPN8100              NO, JUMP TO ERROR PROCESSING
         MVI   OUTOPNFL,YES         SET OPEN FLAG TO YES
* READ INPUT FILE INFORMATION
         LA    R4,INPDCB              LOAD DCB ADDRESS
         USING IHADCB,R4              ADDRESSABILITY OF INPUT DCB
         XR    R5,R5
* READ RECORD BLOCK SIZE
         ICM   R5,B'0011',DCBBLKSI    COPY THE RECORD LENGTH
         ST    R5,INPBLKSI            CLEAR INPLRECL
* READ RECORD LENGTH
         ICM   R5,B'0011',DCBLRECL    COPY THE RECORD LENGTH
         ST    R5,INPLRECL            CLEAR INPLRECL
* READ RECORD FORMAT
         LA    R7,RECFMTBL
OPN2000  EQU   *
         CLC   DCBRECFM(1),4(R7)      COMPARE THE RECORD FORMAT
         BE    OPN2200
         LA    R7,5(,R7)              MOVE TO NEXT RECORD
         CLI   0(R7),X'FF'
         BNE   OPN2000
         B     OPN8300
         DROP  R4
OPN2200  EQU   *
         MVC   INPRECFM(4),0(R7)      COPY THE RECORD FORMAT
* ALLOCATE THE INPUT RECORD BUFFER
         LTR   R5,R5                  TEST IF RECORD LENGTH IS 0
         BNZ   OPN2500
         L     R5,INPBLKSI            LOAD BLOCK SIZE AS RECORD LENGTH
OPN2500  EQU   *
         GETMAIN R,LV=(R5)            GET THE STORAGE
         LTR   R15,R15                TEST THE ALLOCATION CODE
         BNZ   OPN8300                FAILED, PROCESS ERROR MESSAGES
         ST    R1,INBUFADR            SAVE THE STORAGE ADDRESS
         ST    R5,INBUFLEN            SAVE THE STORAGE LENGTH
         B     OPN9000
* INPUT DD IS MISSING
OPN8000  EQU   *
         STC   R15,RETCODE
         MVI   MSGID,MSG006I
         BAL   R4,WRITELOG
         MVC   MSGBUFTX(31),=CL31'EME027I Make sure the input DD '
         MVC   MSGBUFTX+31(8),INDDNAME
         MVC   MSGBUFTX+39(15),=CL15' is allocated.'
         MVC   MSGBUFTX+54(1),RETCODE
         MVI   MSGBUFLN,56
         MVI   MSGID,MSGCUST
         BAL   R4,WRITELOG
         B     OPN8900
* OUTPUT DD IS MISSING
OPN8100  EQU   *
         STC   R15,RETCODE
         MVI   MSGID,MSG007I
         BAL   R4,WRITELOG
         MVC   MSGBUFTX(32),=CL32'EME029I Make sure the output DD '
         MVC   MSGBUFTX+32(8),OUDDNAME
         MVC   MSGBUFTX+40(15),=CL15' is allocated.'
         MVI   MSGBUFLN,55
         MVI   MSGID,MSGCUST
         BAL   R4,WRITELOG
         B     OPN8900
* SYSPRINT DD IS MISSING
OPN8200  EQU   *
         MVI   MSGID,MSG008I
         BAL   R4,WRITELOG
         B     OPN8900
* INPUT RECORD BUFFER ALLCOATION FAILED.
OPN8300  EQU   *
         MVI   MSGID,MSG009I
         BAL   R4,WRITELOG
OPN8900  EQU   *
         MVI   RETCODE,X'08'        SET THE RETURN CODE 10
OPN9000  EQU   *
         BR    R2
*---------------------------------------------------------------------*
* ROUTINE: CLOSFILE
* DESCRIPTION: CLOSE THE FILES
* INPUT:
*    R2  : RETURN CONTROL
* RETURN :
*---------------------------------------------------------------------*
CLOSFILE EQU  *
* CLOSE INPUT DCB IF IT'S OPENED.
         CLI   INPOPNFL,YES
         BNE   CLS1000
         CLOSE INPDCB,MODE=31,MF=(E,INPCLSLF)
CLS1000  EQU   *
* CLOSE OUTPUT DCB IF IT'S OPENED.
         CLI   OUTOPNFL,YES
         BNE   CLS2000
         CLOSE OUTDCB,MODE=31,MF=(E,OUTCLSLF)
CLS2000  EQU   *
* CLOSE SYSPRINT DCB IF IT'S OPENED.
         CLI   SPROPNFL,YES
         BNE   CLS3000
         CLOSE SPRDCB,MODE=31,MF=(E,SPRCLSLF)
CLS3000  EQU   *
* UNALLOCATE INPUT RECORD BUFFER IF IT'S ALLOCATED.
         L     R4,INBUFADR
         LTR   R4,R4
         BZ    CLS4000
         L     R5,INBUFLEN
         FREEMAIN R,LV=(R5),A=(R4)
CLS4000  EQU   *
         BR    R2
*======================================================================
*---------------------------------------------------------------------*
* ROUTINE: CONVERTX
* DESCRIPTION: CONVERT ONE BYTE INTO ASCII, THEN DISPLAYABLE HEX TEXT.
* INPUT:
*    R4   : RETURN CONTROL
*    R5   : THE BYTE TO BE CONVERTED (BIT 24-31)
* RETURN
*    R5   : THE LOWER 16 BITS ARE THE CONVERTED HEX TEXT
* WORK
*    R14  : THE HIGHER HALF BYTE OF R5
*    R15  : THE LOWER  HALF BYTE OF R5
*---------------------------------------------------------------------*
CONVERTX EQU   *                       *
* CONVERT R5 FROM EBCDIC TO ASCII IN R15
         XR    R15,R15               CLEAR R15
         IC    R15,E2ATAB(R5)        CONVERT R5 INTO ASCII TO R15
* SPLTE THE BYTE INTO R14 AND R15
         XR    R14,R14               CLEAR R14
         SLDL  R14,28                SHIFT R14,R15 LEFT 28 BITS
         SRL   R15,28                SHIFT R15 RIGHT 28 BITS BACK
* NOW, HIGHER HALF BYTE IN R14, LOWER HALF BYTE IN R15
         IC    R5,HEXTABLE(R14)      HIGHER HALF BYTE IN R14-> R5
         SLL   R5,8                  SHIFT CONVERTED BYTE LEFT
         IC    R5,HEXTABLE(R15)      LOWER  HALF BYTE IN R15-> R5
* THE CONVERTED TWO BYTES IS IN LOWER 16 BITS OF R5
         BR    R4
*======================================================================
*---------------------------------------------------------------------*
* ROUTINE: CONVERTB
* DESCRIPTION: CONVERT 3 BYTES INTO 4 BYTES IN BASE64
* INPUT:
*    R4   : RETURN CONTROL
*    R5   : THE 3 BYTES TO BE CONVERTED (BIT 08-31)
* RETURN
*    R5   : THE CONVERTED 4 BYTES IN BASE64
* WORK    :
*    R1   : LOOP COUNTER FOR 4 TIMES IN REGISTER
*    R14  : THE CURRENT 6 BITS TO BE PROCESSED, SHIFT 6 BITS FROM R15
*    R15  : THE BYTES LEFT AFTER SHIFTED TO R14
*---------------------------------------------------------------------*
CONVERTB EQU   *                       *
         LR    R15,R5                COPY R5 TO R15
         SLL   R15,8                 SHIFT R15 ONE BYTE LEFT
         LA    R1,4                  LOAD COUNTER
* PROCESS 6 BITS A TIME, TOTAL 4 TIMES.
CVB1000  EQU   *
         XR    R14,R14               CLEAR R14
         SLDL  R14,6                 SHIFT R14,R15 LEFT 6 BITS
         SLL   R5,8                  SHIFT R5 BY 1 BYTE (8 BITS)
         IC    R5,BASE64TB(R14)      SAVE CODE (6->8 BITS) IN R5
         BCT   R1,CVB1000            PROCESS NEXT 6 BITS
* CONVERTED 4 BYTES IS IN R5, USING STM TO GET THEM.
         BR    R4
*======================================================================
*---------------------------------------------------------------------*
* ROUTINE: SHOWINFO
* DESCRIPTION: SHOW STATISTICS INFORMATION
* INPUT:
*    R2  : RETURN CONTROL
* RETURN :
*---------------------------------------------------------------------*
SHOWINFO EQU   *
* TEST THE RETURN CODES FOR LAST MESSAGE
         CLI RETCODE,ZERO
         BNE SIF2000
* SHOW THE STATISTICS FOR INPUT RECORDS
         LA  R9,TOLIRCBI
         LA  R10,MSG013
         BAL R3,SHOWRECS
* SHOW THE STATISTICS FOR OUTPUT RECORDS
         LA  R9,TOLORCBI
         LA  R10,MSG014
         BAL R3,SHOWRECS
* STOP NORMALLY
         MVI MSGID,MSG011I
         B   SIF9000
* STOP WITH WARN MESSAGE
SIF2000  EQU   *
         MVI MSGID,MSG012I
SIF9000  BAL R4,WRITELOG
         BR  R2
*---------------------------------------------------------------------*
* ROUTINE: SHOWRECS
* DESCRIPTION: SHOW STATISTICS INFORMATION FOR ONE TYPE OF RECORD
* INPUT:
*    R3  : RETURN CONTROL
*    R9  : THE FULL WORD ADDRESS OF TOTAL NUMBER OF RECORDS.
*    R10 : THE MESSAGE ADDRESS TO BE SHOWN BEFORE THE NUMBER.
* RETURN :
*---------------------------------------------------------------------*
SHOWRECS EQU   *
*  COPY THE LEADING MESSAGE.
         LH  R5,0(R10)               LOAD THE MESSAGE LENGTH
         LA  R7,2(,R10)              LOAD THE ADDRESS OF MESSAGE
         LA  R6,MSGBUFTX             LOAD THE TARGET STORAGE
         BCTR R5,0
         EX  R5,MVCREC               COPY THE LEADING MESSAGES
         AR  R6,R5                   MOVE R6 TO THE END OF MESSAGE
         LA  R6,1(,R6)
* CONVERT THE RECORD NUMBERS INTO PACKED NUMBER
         L   R5,0(R9)               LOAD THE RECORD NUMBER
         CVD R5,TOLRECPK            CONVERT BIN-TO-DECIMAL
* SET THE EDIT PATTERN 4020...202120
         MVI TOLRECNM,X'40'
         MVI TOLRECNM+1,X'20'
         MVC TOLRECNM+2(14),TOLRECNM+1     INITIAL STORAGE WITH X'20'
         MVI TOLRECNM+14,X'21'             SET SIGNIFICANT BYTE
         ED  TOLRECNM(16),TOLRECPK         EDIT THE LAST 5 BYTES
* REMOVE LEADING SPACES
         LA  R7,TOLRECNM
         LA  R5,16
SRC1000  EQU *
         CLI 0(R7),C' '
         BNE SRC1500
         LA  R7,1(,R7)
         BCT R5,SRC1000
         BCTR R7,0
         MVI 0(R7),C'0'
* SHOW THE STATISTICS MESSAGE
SRC1500  EQU *
         LA  R5,TOLRECNM+16
         SR  R5,R7
         EX  R5,MVCREC                     COPY THE NUMBER
         AR  R6,R5
         MVI 0(R6),C'.'                    SET THE LAST BYTE AS PERIOD
         LA  R6,1(,R6)
         LA  R5,MSGBUFTX                   SAVE THE MESSAGE LENGTH
         SR  R6,R5
         STC R6,MSGBUFLN
         MVI MSGID,MSGCUST
         BAL R4,WRITELOG                   SHOW THE FINAL MESSAGE
         BR R3
*======================================================================
*---------------------------------------------------------------------*
* ROUTINE: WRITELOG
* DESCRIPTION: WRITE LOG TO SYSPRINT DD
* INPUT:
*    R4  : RETURN CONTROL
*  MSDID : MESSAGE ID TO BE DISPLAYED
*        : FOR MSGCUST, DISPLAY CUSTOMIZED MESSAGES.
* RETURN
*---------------------------------------------------------------------*
WRITELOG EQU   *
         CLI  SPROPNFL,YES       IS THE SYSPRINT PROVIDED?
         BNE  WTL9900            NO, JUST SKIP THE LOG
         STM  R5,R7,SVLVL3       SAVE R5-R7 REGISTERS
         CLI  MSGID,MSGCUST      MESSAGE IS PROVIDED IN MESSAGE BUFFER?
         BE   WTL4000
* SEARCH MESSAGE INDEX FOR GIVEN MESSAGE ID IN MSGID
         XR   R6,R6              CLEAR R6
         XR   R7,R7              CLEAR R7
         LA   R5,MSGIDX          LOAD THE START OF THE TABLE
         IC   R6,MSGID           LOAD THE GIVEN MESSAGE ID
WTL1000  EQU   *
         IC   R7,0(R5)           LOAD THE CURRENT MESSAGE ID
         CR   R6,R7              COMPARE THIS ONE TO THE GIVEN ONE.
         BE   WTL2000
         CLI  0(R5),MSGIXEND     GET THE END OF THE TABLE?
         BE   WTL9000            YES, THE GIVEN MSGID IS NOT FOUND
         LA   R5,5(,R5)          MOVE TO NEXT INDEX RECORD
         B    WTL1000            TEST NEXT MESSAGE
* PROCESS MESSAGE ID
WTL2000  EQU   *
         L    R7,1(R5)           LOAD THE MESSAGE ADDRESS
         LH   R5,0(R7)           LOAD THE MESSAGE LENGTH
         LA   R7,2(,R7)          LOAD THE MESSAGE BODY POSITION
         STC  R5,MSGBUFLN        SAVE THE MESSAGE LENGTH TO MSGBUFLN
         BCTR R5,0
         LA   R6,MSGBUFTX        COPY TO MESSAGE BUFFER
         EX   R5,MVCREC          COPY MESSAGE TO SYSPRINT MSG BUFFER
* PROCESS MESSAGES IN MSGBUF BUFFER.
WTL4000 EQU   *
* CLEAN ALL REST OF BUFFER WITH SPACES
         XR   R6,R6
         IC   R6,MSGBUFLN        LOAD MESSAGE BUFFER LENGTH
         LA   R7,MSGBUFTX        LOAD THE MESSAGE ADDRESS
         AR   R7,R6              MOVE TO THE END OF MESSAGE
         MVI  0(R7),C' '         SET BYTE AFTER LAST AS SPACE
         LA   R5,130             MAXIMUM RECORD LENGTH
         SR   R5,R6              GET THE REST RECORD LENGTH
         LA   R6,1(,R7)          MOVE TO NEXT BYTE
         EX   R5,MVCREC          CLEAN REST BUFFER WITH SPACES.
* MESSAGE PAGE BREAK PROCESSING
         CP   MSGCTR,P0          PAGE BREAKER?
         BE   WTL4100
         CP   MSGCTR,P50         PAGE BREAKER?
         BNE  WTL4200
         ZAP  MSGCTR,P0          RESET THE COUNTER
* PAGE BREAK
WTL4100 MVI   MSGBUFCC,C'1'      SET CC BYTE TO SPACE
         B    WTL4300
* NORMAL LINES
WTL4200  MVI  MSGBUFCC,C' '
WTL4300  AP   MSGCTR,P1
         PUT  SPRDCB,MSGBUF      WRITE THE MESSAGE TO SYSPRINT
WTL9000  EQU  *
         LM   R5,R7,SVLVL3       RESTORE R5-R7 REGISTERS
WTL9900  BR   R4
***********************************************************************
*    THIS ROUTINE IS EXECUTED WHEN AN UNRECOVERABLE I/O ERROR HAS     *
*    BEEN ENCOUNTERED DURING AN I/O REQUEST TO A QSAM FILE. THE ERROR *
*    FLAG IS SET, AND DESCRIPTIVE ERROR MESSAGE RETURNED TO THE CALLER*
***********************************************************************
SYNADRTN SYNADAF ACSMETH=QSAM,         SYNAD ERROR ANALYSIS FUNCTION   X
               PARM1=(1),              QSAM STATUS INDICATORS          X
               PARM2=(0)               QSAM DCB
         SYNADRLS                      RELEASE SYNADAF BUFFERS
         B     RETURN                  RETURN TO CALLER
*---------------------------------------------------------------------*
*  DATA  AREAS                                                        *
*---------------------------------------------------------------------*
MVCREC   MVC   0(0,R6),0(R7)      ;COPY RECORD FROM R7 to R6,length R5
YES      EQU   X'01'
NO       EQU   X'00'
ZERO     EQU   X'00'              ZERO IN HEX BINARY
TWO      EQU   X'02'              TWO IN HEX BINARY
* VALID EXEC PARMS
PARMTXT  DC    CL4'TEXT'          TEXT FOR QUOTED PRINTABLE
PARMBIN  DC    CL6'BINARY'        BINARY FOR BASE 64
PARMQTE  DC    CL6'QTEPRT'        QTEPRT FOR QUOTED PRINTABLE
PARMBSE  DC    CL6'BASE64'        BASE64 FOR BASE 64
DEFTINDD DC    CL8'INPUT'         DEFAULT INPUT DD NAME
DEFTOUDD DC    CL8'OUTPUT'        DEFAULT OUTPUT DD NAME
* RECORD FORMAT TABLE
RECFMTBL DS    0C                 RECFM TABLE
         DC    CL4'F   ',XL1'80'
         DC    CL4'FA  ',XL1'84'
         DC    CL4'FM  ',XL1'82'
         DC    CL4'FB  ',XL1'90'
         DC    CL4'FBA ',XL1'94'
         DC    CL4'FBM ',XL1'92'
         DC    CL4'FBS ',XL1'98'
         DC    CL4'FBSA',XL1'9C'
         DC    CL4'FBSM',XL1'9A'
         DC    CL4'V   ',XL1'40'
         DC    CL4'VA  ',XL1'44'
         DC    CL4'VM  ',XL1'42'
         DC    CL4'VB  ',XL1'50'
         DC    CL4'VBA ',XL1'54'
         DC    CL4'VBM ',XL1'52'
         DC    CL4'VBS ',XL1'58'
         DC    CL4'VBSA',XL1'5C'
         DC    CL4'VBSM',XL1'5A'
         DC    CL4'U   ',XL1'C0'
         DC    CL4'    ',XL1'00'
         DC    5X'00'
*---------------------------------------------------------------------*
*EBCDIC-to-ASCII table for Canadian Bilingual CECP Code Page 037
*             000102030405060708090A0B0C0D0E0F
E2ATAB   DS 0CL256
         DC X'00010203DC09C37FCAB2D50B0C0D0E0F' ;00;
         DC X'10111213DBDA08C11819C8F21C1D1E1F' ;10;
         DC X'C4B3C0D9BF0A171BB4C2C5B0B1050607' ;20;
         DC X'CDBA16BCBBC9CC04B9CBCEDF1415FE1A' ;30;
         DC X'20FF838485A0C68687A4BD2E3C282B7C' ;40;
         DC X'268288898AA18C8B8DE121242A293BAA' ;50;
         DC X'2D2FB68EB7B5C78F80A5DD2C255F3E3F' ;60;
         DC X'9B90D2D3D4D6D7D8DE603A2340273D22' ;70;
         DC X'9D616263646566676869AEAFD0ECE7F1' ;80;
         DC X'F86A6B6C6D6E6F707172A6A791F792CF' ;90;
         DC X'E67E737475767778797AADA8D1EDE8A9' ;A0;
         DC X'5E9CBEFAB8F5F4ACABF35B5DEEF9EF9E' ;B0;
         DC X'7B414243444546474849F0939495A2E4' ;C0;
         DC X'7D4A4B4C4D4E4F505152FB968197A398' ;D0;
         DC X'5CF6535455565758595AFDE299E3E0E5' ;E0;
         DC X'30313233343536373839FCEA9AEBE99F' ;F0;
**HEX TABLE FOR UNPACK THE BINARY TO TEXT
HEXTABLE DC CL16'0123456789ABCDEF'
**BASE64 TRANSLATION TABLE
BASE64TB DC C'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
         DC C'0123456789+/'
*---------------------------------------------------------------------*
* CINPDCB CONSTANT DCB/DCBE/OPENLIST
*---------------------------------------------------------------------*
CINPDCB  DCB   DSORG=PS,                                               X
               MACRF=GM,                                               X
               DCBE=CINPDCBE
CINPDCBL EQU   *-CINPDCB               LENGTH OF THE OPENLIST
CINPDCBE DCBE  RMODE31=BUFF,                                           X
               SYNAD=SYNADRTN,         SYNAD ROUTINE ADDRESS           X
               EODAD=EODADRTN          END OF FILE ADDRESS
CINPOPL  OPEN  (CINPDCB,(INPUT)),MODE=31,MF=L
CINPOPLL EQU   *-CINPOPL               LENGTH OF THE OPENLIST
CINPCLS  CLOSE CINPDCB,MODE=31,MF=L
CINPCLSL EQU   *-CINPCLS               LENGTH OF THE CLOSE LIST FORM
* COUTPUT: CONSTANT DCB FOR OUTPUT DCB
COUTDCB  DCB   DSORG=PS,                                               X
               MACRF=PM,                                               X
               RECFM=FB,                                               X
               LRECL=76,                                               X
               DCBE=COUTDCBE
COUTDCBL EQU   *-COUTDCB               LENGTH OF THE OPENLIST
COUTDCBE DCBE  RMODE31=BUFF
COUTOPL  OPEN  (COUTDCB,(OUTPUT)),MODE=31,MF=L
COUTOPLL EQU   *-COUTOPL               LENGTH OF THE OPENLIST
COUTCLS  CLOSE COUTDCB,MODE=31,MF=L
COUTCLSL EQU   *-COUTCLS               LENGTH OF THE CLOSE LIST FORM
* CSPRDCB: CONSTANT DCB FOR SYSPRINT WITH WRITE
CSPRDCB  DCB   DSORG=PS,                                               X
               MACRF=PM,                                               X
               DDNAME=SYSPRINT,                                        X
               RECFM=FBA,                                              X
               LRECL=133,                                              X
               DCBE=CSPRDCBE
CSPRDCBL EQU   *-CSPRDCB               LENGTH OF THE OPENLIST
CSPRDCBE DCBE  RMODE31=BUFF
CSPROPL  OPEN  (CSPRDCB,(OUTPUT)),MODE=31,MF=L
CSPROPLL EQU   *-CSPROPL               LENGTH OF THE OPENLIST
CSPRCLS  CLOSE CSPRDCB,MODE=31,MF=L
CSPRCLSL EQU   *-CSPRCLS               LENGTH OF THE CLOSE LIST FORM
*************************************************************
* PACKED DECIMAL CONSTANTS FOR MESSAGE PROCESSING
P50      DC    PL2'50'       PAGE BREAKER LINES
P1       DC    PL1'1'
P0       DC    PL1'0'
* MESSAGE INDEX TABLE
MSGIDX   DS    0C
*              MSGID    MESSAGE TEXT LOCATION
*              ======== =======================
         DC    AL1(MSG001I),AL4(MSG001)        01
         DC    AL1(MSG002I),AL4(MSG002)        02
         DC    AL1(MSG003I),AL4(MSG003)        03
         DC    AL1(MSG004I),AL4(MSG004)        04
         DC    AL1(MSG005I),AL4(MSG005)        05
         DC    AL1(MSG006I),AL4(MSG006)        06
         DC    AL1(MSG007I),AL4(MSG007)        07
         DC    AL1(MSG008I),AL4(MSG008)        08
         DC    AL1(MSG009I),AL4(MSG009)        09
         DC    AL1(MSG010I),AL4(MSG010)        0A
         DC    AL1(MSG011I),AL4(MSG011)        0B
         DC    AL1(MSG012I),AL4(MSG012)        0C
         DC    AL1(MSG013I),AL4(MSG013)        0D
         DC    AL1(MSG014I),AL4(MSG014)        0E
         DC    AL1(MSG015I),AL4(MSG015)        0F
         DC    AL1(MSG016I),AL4(MSG016)        10
         DC    AL1(MSGIXEND),AL4(0)            END OF TABLE
* END OF MESSAGE INDEX TABLE
***********************************************************
* MESSAGE BODY TABLE
MSG001   DC  AL2(MSG001L)
MSG001T  DC  C'EME001I Welcome to Email Attachment Encoding Program.'
MSG001L  EQU *-MSG001T
MSG001I  EQU X'01'
*
MSG002   DC  AL2(MSG002L)
MSG002T  DC  C'EME002I Design: Hunter Zhou, zhough2000@yahoo.com.    '
MSG002L  EQU *-MSG002T
MSG002I  EQU X'02'
*
MSG003   DC  AL2(MSG003L)
MSG003T  DC  C'EME003I Purpose: Encode Sequential file for TCP/IP '
         DC  C'SMTP Email attachment.'
MSG003L  EQU *-MSG003T
MSG003I  EQU X'03'
*
MSG004   DC  AL2(MSG004L)
MSG004T  DC  C'EME005I Encoding input file using Quoted Printable '
         DC  C'algorithm.'
MSG004L  EQU *-MSG004T
MSG004I  EQU X'04'
*
MSG005   DC  AL2(MSG005L)
MSG005T  DC  C'EME004I Encoding input file using BASE 64 algorithm.'
MSG005L  EQU *-MSG005T
MSG005I  EQU X'05'
*
MSG006   DC  AL2(MSG006L)
MSG006T  DC  C'EME010E There is a problem while opening input file.'
MSG006L  EQU *-MSG006T
MSG006I  EQU X'06'
*
MSG007   DC  AL2(MSG007L)
MSG007T  DC  C'EME011E There is a problem while opening output file.'
MSG007L  EQU *-MSG007T
MSG007I  EQU X'07'
*
MSG008   DC  AL2(MSG008L)
MSG008T  DC  C'EME012E There is a problem while opening SYSPRINT file.'
MSG008L  EQU *-MSG008T
MSG008I  EQU X'08'
*
MSG009   DC  AL2(MSG009L)
MSG009T  DC  C'EME013E There is a problem while reading input file.'
MSG009L  EQU *-MSG009T
MSG009I  EQU X'09'
*
MSG010   DC  AL2(MSG010L)
MSG010T  DC  C'EME020E ERROR: The PARM is invalid, it must be '
         DC  C'TEXT, BINARY, QTEPRD or BASE64!'
MSG010L  EQU *-MSG010T
MSG010I  EQU X'0A'
*
MSG011   DC  AL2(MSG011L)
MSG011T  DC  C'EME030I The EMAILENC program finished normally.'
MSG011L  EQU *-MSG011T
MSG011I  EQU X'0B'
*
MSG012   DC  AL2(MSG012L)
MSG012T  DC  C'EME031W The EMAILENC program finished abnormally.'
MSG012L  EQU *-MSG012T
MSG012I  EQU X'0C'
*
MSG013   DC  AL2(MSG013L)
MSG013T  DC  C'EME040I The total input records processed : '
MSG013L  EQU *-MSG013T
MSG013I  EQU X'0D'
*
MSG014   DC  AL2(MSG014L)
MSG014T  DC  C'EME041I The total output records generated: '
MSG014L  EQU *-MSG014T
MSG014I  EQU X'0E'
*
MSG015   DC  AL2(MSG015L)
MSG015T  DC  C'EME042E The given parameter is longer than 8.'
MSG015L  EQU *-MSG015T
MSG015I  EQU X'0F'
*
MSG016   DC  AL2(MSG016L)
MSG016T  DC  C'EME043E There are more than 3 parameters.'
MSG016L  EQU *-MSG016T
MSG016I  EQU X'10'
*---------------------------------------------------------------------*
*  DSECT DATA, ALLOCATED DYNAMICALLY                                  *
*---------------------------------------------------------------------*
DSA      DSECT
* SAVE AREA MUST BE THE FIRST OF DSA DSECT,
* BECAUSE R13 WILL BE THE BASE REGISTERS FOR THIS DSA,
* AND THE ADDRESS OF OUR SAVE AREA FOR LINKAGE CONVENTION.
SAVEAREA DS    18F                ;REGISTER SAVE AREA
SVLVL1   DS    16F                ;REGISTER SAVE AREA ROUTINE LEVEL 1
SVLVL2   DS    16F                 ;REGISTER SAVE AREA ROUTINE LEVEL 2
SVLVL3   DS    16F                 ;REGISTER SAVE AREA ROUTINE LEVEL 3
RETCODE  DS    XL1                ;RETURN CODE
PARMADR  DS    F                  ;EXEC PARM ADDRESS
* DATA FORMAT, DETERMINATED BY EXEC PARM
PRMWORD  DS    CL8                THE PARMETER WORD TO BE PROCESSED
PRMWSEQ  DS    H                  THE SEQUENCE OF THE CURRENT WORD
PRMWLEN  DS    H                  THE LENGTH OF THE CURRENT WORD
* DATA FORMAT, DETERMINATED BY EXEC PARM
DATAFMT  DS    XL1                DATA FORMAT: TEXT OR BINARY
BASE64   EQU   X'00'              DATA FORMAT: TEXT
QTEPRT   EQU   X'01'              DATA FORMAT: BINARY
* INPUT RECORD BUFFER
INBUFADR DS    F                  INPUT RECORD BUFFER START ADDRESS
INBUFLEN DS    F                  INPUT RECORD BUFFER LENGTH
INPLRECL DS    F                  INPUT: RECORD LENGTH
INPBLKSI DS    F                  INPUT: RECORD BLOCK SIZE
INPRECFM DS    CL4                INPUT: RECORD FORMAT IN TEXT
INPEOF   DS    XL1                OPEN TAG: TELL IF DCB IS OPEN
INPRECST DS    F                  INPUT RECORD DATA START ADDRESS
* OUTPUT RECORD BUFFER
OUTREC   DS    CL76               OUTPUT RECORD
OUTPOS   DS    F                  CURRENT POSITION
* DATA STORAGE FOR BASE 64 ENCODING
* REMAIN BYTES: AT THE END OF RECORDS, THE LEFT BYTES MAY BE
* 0,1 OR 2. THE BYTES WILL BE SAVED IN REMBYTES AND COUNTER WILL
* BE SAVED IN REMCTR
REMBYTES DS    CL2                THE REMAIN BYTES (0, 1 OR 2)
REMCTR   DS    X                  THE TOTOAL BYTES LEFT
* INPUT READ DCB
         DS    0F
INPDCB   DS    XL(CINPDCBL)       DCB FOR QSAM
         DS    0F
INPDCBE  DS    XL(DCBE$LEN)       DCBE FOR QSAM
         DS    0F
INPOPNLF DS    XL(CINPOPLL)       OPEN LIST
         DS    0F
INPCLSLF DS    XL(CINPCLSL)       CLOSE LIST FORM
INPOPNFL DS    XL1                OPEN TAG: TELL IF DCB IS OPEN
INDDNAME DS    CL8                INPUT DDNAME, DEFAULT: INPUT
* OUTPUT WRITE DCB
         DS    0F
OUTDCB   DS    XL(COUTDCBL)       DCB FOR QSAM
         DS    0F
OUTDCBE  DS    XL(DCBE$LEN)       DCBE FOR QSAM
         DS    0F
OUTOPNLF DS    XL(COUTOPLL)       OPEN LIST
         DS    0F
OUTCLSLF DS    XL(COUTCLSL)       CLOSE LIST FORM
OUTOPNFL DS    XL1                OPEN TAG: TELL IF DCB IS OPEN
OUDDNAME DS    CL8                OUTPUT DDNAME, DEFAULT: OUTPUT
* SYSPRINT DCB
         DS    0F
SPRDCB   DS    XL(CSPRDCBL)       DCB FOR QSAM
         DS    0F
SPRDCBE  DS    XL(DCBE$LEN)       DCBE FOR QSAM
         DS    0F
SPROPNLF DS    XL(CSPROPLL)       OPEN LIST FORM
         DS    0F
SPRCLSLF DS    XL(CSPRCLSL)       CLOSE LIST FORM
SPROPNFL DS    XL1                OPEN TAG: TELL IF DCB IS OPEN
* DCBE LENGTH
DCBE$LEN EQU   DCBEEND-DCBE       DCBE length
* MESSAGE BUFFER
MSGBUFLN DS    XL1
MSGBUF   DS    0CL133
MSGBUFCC DS    CL1
MSGBUFTX DS    CL132              ;SYSPRINT MESSAGE BUFFER
MSGCTR   DS    PL2                ;MESSAGE COUNTER
* FLAGS FOR MESSAGE
MSGID    DS    X
MSGCUST  EQU   X'FF'          MESSAGE IS PROVIDED IN MSGBUF, NOT MSGID
MSGIXEND EQU   X'00'              END OF MESSAGE INDEX TABLE TAG
*---------------------------------------------------------------------*
TOLIRCBI DS    F                  INPUT RECORDS IN BINARY NUNBER
TOLORCBI DS    F                 OUTPUT RECORDS IN BINARY NUNBER
TOLRECPK DS    D                  RECORDS IN PACKED DECIMAL
TOLRECNM DS    CL16               RECORDS IN DISPLAYABLE NUMBER
*---------------------------------------------------------------------*
DSALEN   EQU   *-DSA              ;LENGTH OF DATA AREA
*  SYSTEM DSECTS FOR DCB/DCBE
*        Data Control Block (DCB)
         DCBD  DSORG=PS,DEVD=DA
*        DCB Extension (DCBE)
         IHADCBE
*---------------------------------------------------------------------*
*  END OF PROGRAM                                                     *
*---------------------------------------------------------------------*
         END   EMAILENC
